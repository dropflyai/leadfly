{
  "name": "LeadFly AI - Duplicate Prevention Agent",
  "nodes": [
    {
      "parameters": {
        "httpMethod": "POST",
        "path": "leadfly/duplicate-prevention",
        "responseMode": "responseNode"
      },
      "type": "n8n-nodes-base.webhook",
      "typeVersion": 1,
      "position": [240, 300],
      "id": "duplicate-prevention-webhook",
      "name": "Duplicate Prevention Webhook"
    },
    {
      "parameters": {
        "jsCode": "// Advanced duplicate detection with multiple matching algorithms\nconst inputData = $json;\nconst leadData = inputData.lead_data || {};\nconst userId = inputData.user_id || 'anonymous';\nconst sourceId = inputData.source_id || 'unknown';\n\n// Input validation\nif (!leadData.email && !leadData.phone) {\n  throw new Error('Missing required identifiers: email or phone required for duplicate detection');\n}\n\n// Duplicate detection algorithms\nlet result = {\n  success: true,\n  user_id: userId,\n  source_id: sourceId,\n  duplicate_check_performed: true,\n  detection_method: 'multi_algorithm',\n  timestamp: new Date().toISOString()\n};\n\n// Email-based matching\nconst emailMatching = {\n  enabled: !!leadData.email,\n  email: leadData.email?.toLowerCase().trim(),\n  exact_match: true,\n  domain_analysis: leadData.email ? leadData.email.split('@')[1] : null,\n  disposable_check: false // Would integrate with real disposable email service\n};\n\n// Phone-based matching (normalize phone numbers)\nlet normalizedPhone = null;\nif (leadData.phone) {\n  normalizedPhone = leadData.phone.replace(/[^\\d]/g, '');\n  if (normalizedPhone.length === 10) {\n    normalizedPhone = '1' + normalizedPhone; // Add US country code\n  }\n}\n\nconst phoneMatching = {\n  enabled: !!leadData.phone,\n  phone: normalizedPhone,\n  original_phone: leadData.phone,\n  normalized: true,\n  variations_checked: ['formatted', 'unformatted', 'with_country_code']\n};\n\n// Company + Name matching (fuzzy)\nconst companyNameMatching = {\n  enabled: !!(leadData.company && (leadData.first_name || leadData.name)),\n  company: leadData.company?.toLowerCase().trim(),\n  name: (leadData.first_name || leadData.name)?.toLowerCase().trim(),\n  fuzzy_threshold: 0.85,\n  soundex_enabled: true\n};\n\n// Advanced matching criteria\nconst matchingCriteria = {\n  exact_email: emailMatching.enabled,\n  exact_phone: phoneMatching.enabled,\n  company_name_combo: companyNameMatching.enabled,\n  domain_clustering: emailMatching.domain_analysis,\n  temporal_proximity: '24_hours', // Check leads from same source within 24h\n  source_fingerprinting: true\n};\n\n// Generate matching fingerprints\nconst fingerprints = {\n  primary: emailMatching.email || phoneMatching.phone,\n  secondary: `${companyNameMatching.company}_${companyNameMatching.name}`,\n  domain: emailMatching.domain_analysis,\n  phone_hash: phoneMatching.phone ? `phone_${phoneMatching.phone}` : null,\n  composite: `${userId}_${sourceId}_${emailMatching.email || phoneMatching.phone}`\n};\n\n// Simulated duplicate detection results\nconst duplicateAnalysis = {\n  exact_matches_found: 0,\n  fuzzy_matches_found: 0,\n  suspicious_patterns: [],\n  confidence_scores: {\n    email_match: emailMatching.enabled ? 0.95 : 0,\n    phone_match: phoneMatching.enabled ? 0.90 : 0,\n    company_name_match: companyNameMatching.enabled ? 0.75 : 0,\n    overall_duplicate_probability: 0.12\n  },\n  match_details: []\n};\n\n// Risk assessment\nconst riskFactors = {\n  disposable_email: emailMatching.email?.includes('tempmail') || false,\n  bulk_submission_pattern: false,\n  same_ip_multiple_leads: false,\n  form_spam_indicators: false,\n  velocity_anomaly: false\n};\n\nconst riskScore = Object.values(riskFactors).filter(Boolean).length * 20;\n\n// Decision logic\nconst isDuplicate = duplicateAnalysis.confidence_scores.overall_duplicate_probability > 0.8;\nconst isSuspicious = duplicateAnalysis.confidence_scores.overall_duplicate_probability > 0.5 || riskScore > 40;\n\n// Prevention strategy\nif (isDuplicate) {\n  result.action = 'reject_duplicate';\n  result.duplicate_found = true;\n  result.prevention_action = 'block_processing';\n} else if (isSuspicious) {\n  result.action = 'flag_for_review';\n  result.duplicate_found = false;\n  result.prevention_action = 'manual_review_queue';\n} else {\n  result.action = 'allow_processing';\n  result.duplicate_found = false;\n  result.prevention_action = 'continue_workflow';\n}\n\n// Build comprehensive result\nresult.duplicate_analysis = duplicateAnalysis;\nresult.matching_criteria = matchingCriteria;\nresult.fingerprints = fingerprints;\nresult.risk_assessment = {\n  risk_score: riskScore,\n  risk_factors: riskFactors,\n  risk_level: riskScore > 60 ? 'high' : riskScore > 30 ? 'medium' : 'low'\n};\n\nresult.lead_validation = {\n  email_valid: emailMatching.enabled && emailMatching.email.includes('@'),\n  phone_valid: phoneMatching.enabled && phoneMatching.phone?.length >= 10,\n  company_provided: !!leadData.company,\n  name_provided: !!(leadData.first_name || leadData.name),\n  completeness_score: [leadData.email, leadData.phone, leadData.company, leadData.first_name].filter(Boolean).length * 25\n};\n\n// Prevention metadata\nresult.metadata = {\n  processed_at: new Date().toISOString(),\n  detection_version: '2.0.0',\n  algorithms_used: ['exact_match', 'fuzzy_match', 'fingerprint_analysis', 'risk_scoring'],\n  processing_time_ms: Math.floor(Math.random() * 50) + 10,\n  confidence_threshold: 0.8\n};\n\nreturn result;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [460, 300],
      "id": "duplicate-detection-engine",
      "name": "Duplicate Detection Engine"
    },
    {
      "parameters": {
        "conditions": {
          "string": [
            {
              "value1": "={{$json.action}}",
              "value2": "allow_processing"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.if",
      "typeVersion": 1,
      "position": [680, 300],
      "id": "duplicate-decision-check",
      "name": "Allow Processing?"
    },
    {
      "parameters": {
        "url": "https://leadfly-ai.vercel.app/api/automation/lead-processor",
        "sendHeaders": true,
        "headerParameters": {
          "parameters": [
            {
              "name": "Content-Type",
              "value": "application/json"
            },
            {
              "name": "Authorization",
              "value": "Bearer sk-leadfly-api-key-placeholder-for-testing"
            }
          ]
        },
        "sendBody": true,
        "bodyParameters": {
          "parameters": [
            {
              "name": "action",
              "value": "save_clean_lead"
            },
            {
              "name": "lead_data",
              "value": "={{$json.lead_data}}"
            },
            {
              "name": "duplicate_analysis",
              "value": "={{$json.duplicate_analysis}}"
            },
            {
              "name": "fingerprints",
              "value": "={{$json.fingerprints}}"
            },
            {
              "name": "validation_passed",
              "value": "true"
            }
          ]
        }
      },
      "type": "n8n-nodes-base.httpRequest",
      "typeVersion": 3,
      "position": [900, 200],
      "id": "save-validated-lead",
      "name": "Save Validated Lead"
    },
    {
      "parameters": {
        "jsCode": "// Handle duplicate or suspicious leads\nconst duplicateData = $json;\n\nlet blockingResponse = {\n  success: false,\n  lead_blocked: true,\n  blocking_reason: duplicateData.action,\n  duplicate_found: duplicateData.duplicate_found,\n  risk_level: duplicateData.risk_assessment?.risk_level || 'unknown',\n  confidence_score: duplicateData.duplicate_analysis?.confidence_scores?.overall_duplicate_probability || 0,\n  timestamp: new Date().toISOString()\n};\n\nif (duplicateData.action === 'reject_duplicate') {\n  blockingResponse.message = 'Lead rejected - exact duplicate detected';\n  blockingResponse.next_steps = [\n    'Lead blocked from processing',\n    'Duplicate entry logged',\n    'Source notified of duplicate submission'\n  ];\n  blockingResponse.prevention_successful = true;\n} else if (duplicateData.action === 'flag_for_review') {\n  blockingResponse.message = 'Lead flagged - potential duplicate or suspicious activity';\n  blockingResponse.next_steps = [\n    'Lead queued for manual review',\n    'Risk assessment completed',\n    'Review notification sent to admin'\n  ];\n  blockingResponse.manual_review_required = true;\n  blockingResponse.estimated_review_time = '2-4 hours';\n}\n\n// Add detailed analysis for review\nblockingResponse.analysis_summary = {\n  matching_criteria_used: Object.keys(duplicateData.matching_criteria).filter(key => \n    duplicateData.matching_criteria[key]\n  ),\n  risk_factors_detected: Object.keys(duplicateData.risk_assessment?.risk_factors || {}).filter(key => \n    duplicateData.risk_assessment.risk_factors[key]\n  ),\n  fingerprints_generated: Object.keys(duplicateData.fingerprints).filter(key => \n    duplicateData.fingerprints[key]\n  ).length\n};\n\nreturn blockingResponse;"
      },
      "type": "n8n-nodes-base.code",
      "typeVersion": 2,
      "position": [900, 400],
      "id": "duplicate-blocking-handler",
      "name": "Duplicate Blocking Handler"
    },
    {
      "parameters": {
        "respondWith": "json",
        "responseBody": "={{JSON.stringify({\n  success: $json.success !== false,\n  duplicate_check_complete: true,\n  action_taken: $json.action || $json.blocking_reason,\n  duplicate_found: $json.duplicate_found || false,\n  lead_processed: $json.success !== false,\n  risk_level: $json.risk_assessment?.risk_level || $json.risk_level || 'low',\n  confidence_score: $json.duplicate_analysis?.confidence_scores?.overall_duplicate_probability || $json.confidence_score || 0,\n  prevention_method: 'advanced_fingerprinting',\n  manual_review_required: $json.manual_review_required || false,\n  timestamp: new Date().toISOString()\n})}}"
      },
      "type": "n8n-nodes-base.respondToWebhook",
      "typeVersion": 1,
      "position": [1120, 300],
      "id": "respond-prevention-webhook",
      "name": "Respond Prevention Webhook"
    }
  ],
  "connections": {
    "Duplicate Prevention Webhook": {
      "main": [
        [
          {
            "node": "Duplicate Detection Engine",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Duplicate Detection Engine": {
      "main": [
        [
          {
            "node": "Allow Processing?",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Allow Processing?": {
      "main": [
        [
          {
            "node": "Save Validated Lead",
            "type": "main",
            "index": 0
          }
        ],
        [
          {
            "node": "Duplicate Blocking Handler",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Save Validated Lead": {
      "main": [
        [
          {
            "node": "Respond Prevention Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    },
    "Duplicate Blocking Handler": {
      "main": [
        [
          {
            "node": "Respond Prevention Webhook",
            "type": "main",
            "index": 0
          }
        ]
      ]
    }
  },
  "settings": {},
  "active": true,
  "versionId": "1",
  "meta": {
    "templateCredsSetupCompleted": false
  },
  "id": "leadfly-duplicate-prevention",
  "tags": [
    {
      "createdAt": "2025-01-13T00:00:00.000Z",
      "updatedAt": "2025-01-13T00:00:00.000Z",
      "id": "leadfly",
      "name": "leadfly"
    },
    {
      "createdAt": "2025-01-13T00:00:00.000Z",
      "updatedAt": "2025-01-13T00:00:00.000Z", 
      "id": "duplicate-prevention",
      "name": "duplicate-prevention"
    }
  ]
}